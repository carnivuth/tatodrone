<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Tatodrone</title>
    <link rel="stylesheet" href="styles/desktop.css">
    <link rel="stylesheet" href="styles/mobile.css">
  </head>
  <body>
    <div id="main-box">

      <canvas id="display"></canvas>

      <div id="control-panel">

        <h2>Game Controls</h2>

        <!-- drone movements control section -->
        <div class="control-section" id="drone-movement-controls" >

          <input type="button" id="forward" value="w" class="controls">

          <input type="button" id="backward" value="s" class="controls">

          <input type="button" id="up" value="k" class="controls">

          <input type="button" id="down" value="j" class="controls">

        </div>

        <!-- drone rotation control section -->
        <div class="control-section" id="drone-rotation-controls" >

          <input type="button" id="left" value="a", class="controls" >

          <input type="button" id="right" value="d" class="controls" >

        </div>
        <!-- light control section -->
        <div class="control-section" id="light-controls" >

          <input type="range" id="light-intensity" value="1" min="0" step="0.01" max="1" class="controls" >

        </div>

      </div>
    </div>
  </body>

  <!-- vertex shader -->
  <script id="3d-vertex-shader"  type="x-shader/x-fragment">

attribute vec4 a_position;
attribute vec3 a_normal;
attribute vec2 a_texcoord;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
uniform vec3 u_camera_position;
uniform vec3 u_light_position;

varying vec3 v_camera_position;
varying vec3 v_view_direction;
varying vec3 v_light_direction;
varying vec2 v_texcoord;
varying vec3 v_normal;
varying vec3 v_light_position;
varying vec4 world_position;

void main() {

  // compute vertex position in the world
  world_position = u_world * a_position;

  // compute light direction w.r.t. the vertex to pass to the fragment shader
  v_light_direction = u_light_position - world_position.xyz ;

  // pass texture coordintates to the fragment shader
  v_texcoord = a_texcoord;

  // pass vertex normal to the fragment shader
  v_normal = a_normal;


  // compute camera view direction to pass to the fragment shader
  v_view_direction = u_camera_position - world_position.xyz;


  // compute vertex position in the screen
  gl_Position = u_projection * u_view * world_position;
}
  </script>
  <!-- fragment shader -->
  <script id="3d-fragment-shader"  type="x-shader/x-fragment">

precision highp float;

varying vec2 v_texcoord;
varying vec3 v_normal;
varying vec3 v_view_direction;
varying vec3 v_light_direction;

uniform vec3 diffuse;

// color of the object in terms of light components reflected
uniform vec3 ambient;

// light emitted from the object
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;

// light parameters
uniform vec3 u_light_color;
uniform sampler2D texture;

// fragment color following the phong illumination model

// IaKa +IdKd(L dot N) + IsKs(R dot V)^n
void main () {

  // texture color
  vec4 texture_color = texture2D(texture, v_texcoord);

  // (L dot N)
  float diffuse_angle = max(dot(normalize(v_light_direction),normalize(v_normal)),0.0);

  // R vector
  vec3 R = reflect(v_light_direction,v_normal);

  // (R dot V)
  float specular_angle = max(dot(normalize(R),normalize(v_view_direction)),0.0);

  gl_FragColor = vec4(
                      vec3(
                        emissive +

                        // ambient component https://carnivuth.github.io/computer_graphics/pages/ILLUMINAZIONE#componente-dambiente
                          ambient * u_light_color +

                          // diffuse component https://carnivuth.github.io/computer_graphics/pages/ILLUMINAZIONE#componente-di-riflessione-diffusa
                          diffuse *  u_light_color * texture_color.xyz * diffuse_angle +

                          // specular component https://carnivuth.github.io/computer_graphics/pages/ILLUMINAZIONE#componente-di-riflessione-speculare
                          specular * u_light_color * pow(specular_angle,shininess)
                      )
                  ,texture_color.a * opacity);
}
  </script>

  <!-- DEBUGGER -->
  <script type="text/javascript" src="src/lib/spector.js"></script>

  <!-- import javascript libs -->
  <script type="text/javascript" src="src/lib/mesh_utils.js"></script>
  <script type="text/javascript" src="src/lib/glm_utils.js"></script>
  <script type="text/javascript" src="src/lib/webgl-debug.js"></script>
  <script type="text/javascript" src="src/lib/webgl-utils.js"></script>
  <script type="text/javascript" src="src/lib/m4.js"></script>
  <script type="text/javascript" src="src/lib/jquery-3.6.0.js"></script>
  <script type="text/javascript" src="src/lib/dat.gui.js"></script>
  <script type="text/javascript" src="src/lib/load_mesh.js"></script>
  <script type="text/javascript" src="src/lib/debug.js"></script>

  <!-- import javascript source files -->
  <script type="text/javascript" src="src/lib/utils.js"></script>
  <script type="text/javascript" src="src/scene/model.js"></script>
  <script type="text/javascript" src="src/scene/drone.js"></script>
  <script type="text/javascript" src="src/scene/camera.js"></script>
  <script type="text/javascript" src="src/scene/light.js"></script>
  <script type="text/javascript" src="src/controls/controls.js"></script>
  <script type="text/javascript" src="src/controls/keyboard.js"></script>
  <script type="text/javascript" src="src/controls/buttons.js"></script>
  <script type="text/javascript" src="src/controls/gestures.js"></script>
  <script type="text/javascript" src="src/main.js"></script>

</html>
