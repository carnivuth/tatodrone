<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Drone</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div id="main-box">
      <canvas id="display"></canvas>
      <div id="control-panel">
        <h2>Game Controls</h2>

        <!-- drone movements control section -->
        <div class="control-section" id="drone-movement-controls" >

          <input type="button" id="forward" value="Forward">

          <input type="button" id="Backward" value="Backward">

          <input type="button" id="up" value="Up">

          <input type="button" id="down" value="Down" >

        </div>

        <!-- drone rotation control section -->
        <div class="control-section" id="drone-rotation-controls" >

          <input type="button" id="left" value="Left">

          <input type="button" id="right" value="Right">

        </div>

        <div id="control-panel-footer">
          <a href="#">Help</a> | <a href="#">Settings</a>
        </div>
      </div>
    </div>
  </body>

  <!-- vertex shader -->
  <script id="3d-vertex-shader"  type="x-shader/x-fragment">

attribute vec4 a_position;
attribute vec3 a_normal;
attribute vec2 a_texcoord;

uniform mat4 u_projection;
uniform mat4 u_view;
uniform mat4 u_world;
uniform vec3 u_camera_position;

varying vec3 v_view_direction;
varying vec2 v_texcoord;
varying vec3 v_normal;

void main() {

  // compute vertex position in the world
  vec4 world_position = u_world * a_position;

  // pass texture coordintates to the fragment shader
  v_texcoord = a_texcoord;

  // pass vertex normal to the fragment shader
  v_normal = a_normal;

  // compute camera view direction
  v_view_direction = u_camera_position - world_position.xyz;

  // compute vertex position in the screen
  gl_Position = u_projection * u_view * world_position;
}
  </script>
  <!-- fragment shader -->
  <script id="3d-fragment-shader"  type="x-shader/x-fragment">

precision highp float;

varying vec2 v_texcoord;
varying vec3 v_normal;
varying vec3 v_view_direction;

uniform vec3 diffuse;

// color of the object in terms of light components reflected
uniform vec3 ambient;

// light emitted from the object
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;

// light parameters
uniform vec3 u_lightDirection;
uniform vec3 u_lightPosition;
uniform vec3 u_lightColor;
uniform sampler2D diffuseMap;

void main () {

  vec4 diffuseMapColor = texture2D(diffuseMap, v_texcoord);
  float effectiveOpacity = opacity * diffuseMapColor.a;

  //gl_FragColor = vec4(200,0,0,1);
  //gl_FragColor = vec4(0,0,0,1);
  vec3 normal = normalize(v_normal);
//  1
//  2     vec3 surfaceToViewDirection = normalize(v_surfaceToView);
//  3     vec3 halfVector = normalize(u_lightDirection + surfaceToViewDirection);
//  4
//  5     float fakeLight = dot(u_lightDirection, normal) * .5 + .5;
//  6     float specularLight = clamp(dot(normal, halfVector), 0.0, 1.0);
//  7
//  8     vec4 diffuseMapColor = texture2D(diffuseMap, v_texcoord);
//  9     vec3 effectiveDiffuse = diffuse * diffuseMapColor.rgb * v_color.rgb;
// 10     float effectiveOpacity = opacity * diffuseMapColor.a * v_color.a;
// 11
// 12     gl_FragColor = vec4(
// 13         emissive +
// 14         ambient * u_lightColor +
// 15         effectiveDiffuse * fakeLight +
// 16         specular * pow(specularLight, shininess),
// 17         effectiveOpacity);
  gl_FragColor = vec4(

                  // rescale colors
                  vec3(255,255,255)*(vec3(1,1,1) -
                      vec3(
                        emissive +
                        // ambient component https://carnivuth.github.io/computer_graphics/pages/ILLUMINAZIONE#componente-dambiente
                        ambient * u_lightColor +
                        // diffuse component https://carnivuth.github.io/computer_graphics/pages/ILLUMINAZIONE#componente-di-riflessione-diffusa
                        diffuse * diffuseMapColor.xyz * u_lightColor *normalize(dot(normalize(v_normal),u_lightDirection)) * .5 + .5 +
                        // specular component https://carnivuth.github.io/computer_graphics/pages/ILLUMINAZIONE#componente-di-riflessione-speculare
                        specular * pow(clamp(dot(normalize(v_normal),normalize(u_lightDirection + normalize(v_view_direction))),0.0,1.0),shininess)

                      )
                  )
                ,diffuseMapColor.a * opacity);
}
  </script>

  <!-- DEBUGGER -->
  <script type="text/javascript" src="src/lib/spector.js"></script>

  <!-- import javascript libs -->
  <script type="text/javascript" src="src/lib/mesh_utils.js"></script>
  <script type="text/javascript" src="src/lib/glm_utils.js"></script>
  <script type="text/javascript" src="src/lib/webgl-debug.js"></script>
  <script type="text/javascript" src="src/lib/webgl-utils.js"></script>
  <script type="text/javascript" src="src/lib/m4.js"></script>
  <script type="text/javascript" src="src/lib/jquery-3.6.0.js"></script>
  <script type="text/javascript" src="src/lib/dat.gui.js"></script>
  <script type="text/javascript" src="src/lib/load_mesh.js"></script>
  <script type="text/javascript" src="src/lib/debug.js"></script>

  <!-- import javascript source files -->
  <script type="text/javascript" src="src/lib/utils.js"></script>
  <script type="text/javascript" src="src/scene/model.js"></script>
  <script type="text/javascript" src="src/scene/drone.js"></script>
  <script type="text/javascript" src="src/scene/camera.js"></script>
  <script type="text/javascript" src="src/scene/light.js"></script>
  <script type="text/javascript" src="src/controls/controls.js"></script>
  <script type="text/javascript" src="src/controls/keyboard.js"></script>
  <script type="text/javascript" src="src/main.js"></script>

</html>
